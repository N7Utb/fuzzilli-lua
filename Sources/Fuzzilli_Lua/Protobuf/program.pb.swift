// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: program.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct FuzzilliLua_Protobuf_Instruction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The operation is either encoded as an index, referring to the nth operation
  /// (so that shared operations are also only present once in the protobuf), or
  /// as one of the many concrete Operation messages.
  public var inouts: [UInt32] = []

  public var numinputs: UInt32 = 0

  public var numoutputs: UInt32 = 0

  public var numinneroutputs: UInt32 = 0

  public var operation: FuzzilliLua_Protobuf_Instruction.OneOf_Operation? = nil

  public var opIdx: UInt32 {
    get {
      if case .opIdx(let v)? = operation {return v}
      return 0
    }
    set {operation = .opIdx(newValue)}
  }

  /// TODO fixup keys
  public var loadNumber: FuzzilliLua_Protobuf_LoadNumber {
    get {
      if case .loadNumber(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_LoadNumber()
    }
    set {operation = .loadNumber(newValue)}
  }

  public var loadString: FuzzilliLua_Protobuf_LoadString {
    get {
      if case .loadString(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_LoadString()
    }
    set {operation = .loadString(newValue)}
  }

  public var loadBoolean: FuzzilliLua_Protobuf_LoadBoolean {
    get {
      if case .loadBoolean(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_LoadBoolean()
    }
    set {operation = .loadBoolean(newValue)}
  }

  public var loadNil: FuzzilliLua_Protobuf_LoadNil {
    get {
      if case .loadNil(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_LoadNil()
    }
    set {operation = .loadNil(newValue)}
  }

  public var loadPair: FuzzilliLua_Protobuf_LoadPair {
    get {
      if case .loadPair(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_LoadPair()
    }
    set {operation = .loadPair(newValue)}
  }

  public var beginTable: FuzzilliLua_Protobuf_BeginTable {
    get {
      if case .beginTable(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_BeginTable()
    }
    set {operation = .beginTable(newValue)}
  }

  public var tableAddProperty: FuzzilliLua_Protobuf_TableAddProperty {
    get {
      if case .tableAddProperty(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_TableAddProperty()
    }
    set {operation = .tableAddProperty(newValue)}
  }

  public var tableAddElement: FuzzilliLua_Protobuf_TableAddElement {
    get {
      if case .tableAddElement(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_TableAddElement()
    }
    set {operation = .tableAddElement(newValue)}
  }

  public var beginTableMethod: FuzzilliLua_Protobuf_BeginTableMethod {
    get {
      if case .beginTableMethod(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_BeginTableMethod()
    }
    set {operation = .beginTableMethod(newValue)}
  }

  public var endTableMethod: FuzzilliLua_Protobuf_EndTableMethod {
    get {
      if case .endTableMethod(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_EndTableMethod()
    }
    set {operation = .endTableMethod(newValue)}
  }

  public var endTable: FuzzilliLua_Protobuf_EndTable {
    get {
      if case .endTable(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_EndTable()
    }
    set {operation = .endTable(newValue)}
  }

  public var createArray: FuzzilliLua_Protobuf_CreateArray {
    get {
      if case .createArray(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_CreateArray()
    }
    set {operation = .createArray(newValue)}
  }

  public var loadBuiltin: FuzzilliLua_Protobuf_LoadBuiltin {
    get {
      if case .loadBuiltin(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_LoadBuiltin()
    }
    set {operation = .loadBuiltin(newValue)}
  }

  public var getProperty: FuzzilliLua_Protobuf_GetProperty {
    get {
      if case .getProperty(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_GetProperty()
    }
    set {operation = .getProperty(newValue)}
  }

  public var setProperty: FuzzilliLua_Protobuf_SetProperty {
    get {
      if case .setProperty(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_SetProperty()
    }
    set {operation = .setProperty(newValue)}
  }

  public var updateProperty: FuzzilliLua_Protobuf_UpdateProperty {
    get {
      if case .updateProperty(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_UpdateProperty()
    }
    set {operation = .updateProperty(newValue)}
  }

  public var deleteProperty: FuzzilliLua_Protobuf_DeleteProperty {
    get {
      if case .deleteProperty(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_DeleteProperty()
    }
    set {operation = .deleteProperty(newValue)}
  }

  public var getElement: FuzzilliLua_Protobuf_GetElement {
    get {
      if case .getElement(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_GetElement()
    }
    set {operation = .getElement(newValue)}
  }

  public var setElement: FuzzilliLua_Protobuf_SetElement {
    get {
      if case .setElement(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_SetElement()
    }
    set {operation = .setElement(newValue)}
  }

  public var updateElement: FuzzilliLua_Protobuf_UpdateElement {
    get {
      if case .updateElement(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_UpdateElement()
    }
    set {operation = .updateElement(newValue)}
  }

  public var deleteElement: FuzzilliLua_Protobuf_DeleteElement {
    get {
      if case .deleteElement(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_DeleteElement()
    }
    set {operation = .deleteElement(newValue)}
  }

  public var beginFunction: FuzzilliLua_Protobuf_BeginFunction {
    get {
      if case .beginFunction(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_BeginFunction()
    }
    set {operation = .beginFunction(newValue)}
  }

  public var endFunction: FuzzilliLua_Protobuf_EndFunction {
    get {
      if case .endFunction(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_EndFunction()
    }
    set {operation = .endFunction(newValue)}
  }

  public var `return`: FuzzilliLua_Protobuf_Return {
    get {
      if case .return(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_Return()
    }
    set {operation = .return(newValue)}
  }

  public var callFunction: FuzzilliLua_Protobuf_CallFunction {
    get {
      if case .callFunction(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_CallFunction()
    }
    set {operation = .callFunction(newValue)}
  }

  public var callMethod: FuzzilliLua_Protobuf_CallMethod {
    get {
      if case .callMethod(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_CallMethod()
    }
    set {operation = .callMethod(newValue)}
  }

  public var unaryOperation: FuzzilliLua_Protobuf_UnaryOperation {
    get {
      if case .unaryOperation(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_UnaryOperation()
    }
    set {operation = .unaryOperation(newValue)}
  }

  public var binaryOperation: FuzzilliLua_Protobuf_BinaryOperation {
    get {
      if case .binaryOperation(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_BinaryOperation()
    }
    set {operation = .binaryOperation(newValue)}
  }

  public var update: FuzzilliLua_Protobuf_Update {
    get {
      if case .update(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_Update()
    }
    set {operation = .update(newValue)}
  }

  public var reassign: FuzzilliLua_Protobuf_Reassign {
    get {
      if case .reassign(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_Reassign()
    }
    set {operation = .reassign(newValue)}
  }

  public var compare: FuzzilliLua_Protobuf_Compare {
    get {
      if case .compare(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_Compare()
    }
    set {operation = .compare(newValue)}
  }

  public var beginIf: FuzzilliLua_Protobuf_BeginIf {
    get {
      if case .beginIf(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_BeginIf()
    }
    set {operation = .beginIf(newValue)}
  }

  public var beginElse: FuzzilliLua_Protobuf_BeginElse {
    get {
      if case .beginElse(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_BeginElse()
    }
    set {operation = .beginElse(newValue)}
  }

  public var endIf: FuzzilliLua_Protobuf_EndIf {
    get {
      if case .endIf(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_EndIf()
    }
    set {operation = .endIf(newValue)}
  }

  public var beginWhileLoopHeader: FuzzilliLua_Protobuf_BeginWhileLoopHeader {
    get {
      if case .beginWhileLoopHeader(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_BeginWhileLoopHeader()
    }
    set {operation = .beginWhileLoopHeader(newValue)}
  }

  public var beginWhileLoopBody: FuzzilliLua_Protobuf_BeginWhileLoopBody {
    get {
      if case .beginWhileLoopBody(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_BeginWhileLoopBody()
    }
    set {operation = .beginWhileLoopBody(newValue)}
  }

  public var endWhileLoop: FuzzilliLua_Protobuf_EndWhileLoop {
    get {
      if case .endWhileLoop(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_EndWhileLoop()
    }
    set {operation = .endWhileLoop(newValue)}
  }

  public var beginForLoopInitializer: FuzzilliLua_Protobuf_BeginForLoopInitializer {
    get {
      if case .beginForLoopInitializer(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_BeginForLoopInitializer()
    }
    set {operation = .beginForLoopInitializer(newValue)}
  }

  public var beginForLoopCondition: FuzzilliLua_Protobuf_BeginForLoopCondition {
    get {
      if case .beginForLoopCondition(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_BeginForLoopCondition()
    }
    set {operation = .beginForLoopCondition(newValue)}
  }

  public var beginForLoopAfterthought: FuzzilliLua_Protobuf_BeginForLoopAfterthought {
    get {
      if case .beginForLoopAfterthought(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_BeginForLoopAfterthought()
    }
    set {operation = .beginForLoopAfterthought(newValue)}
  }

  public var beginForLoopBody: FuzzilliLua_Protobuf_BeginForLoopBody {
    get {
      if case .beginForLoopBody(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_BeginForLoopBody()
    }
    set {operation = .beginForLoopBody(newValue)}
  }

  public var endForLoop: FuzzilliLua_Protobuf_EndForLoop {
    get {
      if case .endForLoop(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_EndForLoop()
    }
    set {operation = .endForLoop(newValue)}
  }

  public var beginForInLoop: FuzzilliLua_Protobuf_BeginForInLoop {
    get {
      if case .beginForInLoop(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_BeginForInLoop()
    }
    set {operation = .beginForInLoop(newValue)}
  }

  public var endForInLoop: FuzzilliLua_Protobuf_EndForInLoop {
    get {
      if case .endForInLoop(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_EndForInLoop()
    }
    set {operation = .endForInLoop(newValue)}
  }

  public var beginRepeatLoop: FuzzilliLua_Protobuf_BeginRepeatLoop {
    get {
      if case .beginRepeatLoop(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_BeginRepeatLoop()
    }
    set {operation = .beginRepeatLoop(newValue)}
  }

  public var endRepeatLoop: FuzzilliLua_Protobuf_EndRepeatLoop {
    get {
      if case .endRepeatLoop(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_EndRepeatLoop()
    }
    set {operation = .endRepeatLoop(newValue)}
  }

  public var loopBreak: FuzzilliLua_Protobuf_LoopBreak {
    get {
      if case .loopBreak(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_LoopBreak()
    }
    set {operation = .loopBreak(newValue)}
  }

  public var label: FuzzilliLua_Protobuf_Label {
    get {
      if case .label(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_Label()
    }
    set {operation = .label(newValue)}
  }

  public var goto: FuzzilliLua_Protobuf_Goto {
    get {
      if case .goto(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_Goto()
    }
    set {operation = .goto(newValue)}
  }

  public var nop: FuzzilliLua_Protobuf_Nop {
    get {
      if case .nop(let v)? = operation {return v}
      return FuzzilliLua_Protobuf_Nop()
    }
    set {operation = .nop(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Operation: Equatable {
    case opIdx(UInt32)
    /// TODO fixup keys
    case loadNumber(FuzzilliLua_Protobuf_LoadNumber)
    case loadString(FuzzilliLua_Protobuf_LoadString)
    case loadBoolean(FuzzilliLua_Protobuf_LoadBoolean)
    case loadNil(FuzzilliLua_Protobuf_LoadNil)
    case loadPair(FuzzilliLua_Protobuf_LoadPair)
    case beginTable(FuzzilliLua_Protobuf_BeginTable)
    case tableAddProperty(FuzzilliLua_Protobuf_TableAddProperty)
    case tableAddElement(FuzzilliLua_Protobuf_TableAddElement)
    case beginTableMethod(FuzzilliLua_Protobuf_BeginTableMethod)
    case endTableMethod(FuzzilliLua_Protobuf_EndTableMethod)
    case endTable(FuzzilliLua_Protobuf_EndTable)
    case createArray(FuzzilliLua_Protobuf_CreateArray)
    case loadBuiltin(FuzzilliLua_Protobuf_LoadBuiltin)
    case getProperty(FuzzilliLua_Protobuf_GetProperty)
    case setProperty(FuzzilliLua_Protobuf_SetProperty)
    case updateProperty(FuzzilliLua_Protobuf_UpdateProperty)
    case deleteProperty(FuzzilliLua_Protobuf_DeleteProperty)
    case getElement(FuzzilliLua_Protobuf_GetElement)
    case setElement(FuzzilliLua_Protobuf_SetElement)
    case updateElement(FuzzilliLua_Protobuf_UpdateElement)
    case deleteElement(FuzzilliLua_Protobuf_DeleteElement)
    case beginFunction(FuzzilliLua_Protobuf_BeginFunction)
    case endFunction(FuzzilliLua_Protobuf_EndFunction)
    case `return`(FuzzilliLua_Protobuf_Return)
    case callFunction(FuzzilliLua_Protobuf_CallFunction)
    case callMethod(FuzzilliLua_Protobuf_CallMethod)
    case unaryOperation(FuzzilliLua_Protobuf_UnaryOperation)
    case binaryOperation(FuzzilliLua_Protobuf_BinaryOperation)
    case update(FuzzilliLua_Protobuf_Update)
    case reassign(FuzzilliLua_Protobuf_Reassign)
    case compare(FuzzilliLua_Protobuf_Compare)
    case beginIf(FuzzilliLua_Protobuf_BeginIf)
    case beginElse(FuzzilliLua_Protobuf_BeginElse)
    case endIf(FuzzilliLua_Protobuf_EndIf)
    case beginWhileLoopHeader(FuzzilliLua_Protobuf_BeginWhileLoopHeader)
    case beginWhileLoopBody(FuzzilliLua_Protobuf_BeginWhileLoopBody)
    case endWhileLoop(FuzzilliLua_Protobuf_EndWhileLoop)
    case beginForLoopInitializer(FuzzilliLua_Protobuf_BeginForLoopInitializer)
    case beginForLoopCondition(FuzzilliLua_Protobuf_BeginForLoopCondition)
    case beginForLoopAfterthought(FuzzilliLua_Protobuf_BeginForLoopAfterthought)
    case beginForLoopBody(FuzzilliLua_Protobuf_BeginForLoopBody)
    case endForLoop(FuzzilliLua_Protobuf_EndForLoop)
    case beginForInLoop(FuzzilliLua_Protobuf_BeginForInLoop)
    case endForInLoop(FuzzilliLua_Protobuf_EndForInLoop)
    case beginRepeatLoop(FuzzilliLua_Protobuf_BeginRepeatLoop)
    case endRepeatLoop(FuzzilliLua_Protobuf_EndRepeatLoop)
    case loopBreak(FuzzilliLua_Protobuf_LoopBreak)
    case label(FuzzilliLua_Protobuf_Label)
    case goto(FuzzilliLua_Protobuf_Goto)
    case nop(FuzzilliLua_Protobuf_Nop)

  #if !swift(>=4.1)
    public static func ==(lhs: FuzzilliLua_Protobuf_Instruction.OneOf_Operation, rhs: FuzzilliLua_Protobuf_Instruction.OneOf_Operation) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.opIdx, .opIdx): return {
        guard case .opIdx(let l) = lhs, case .opIdx(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadNumber, .loadNumber): return {
        guard case .loadNumber(let l) = lhs, case .loadNumber(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadString, .loadString): return {
        guard case .loadString(let l) = lhs, case .loadString(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadBoolean, .loadBoolean): return {
        guard case .loadBoolean(let l) = lhs, case .loadBoolean(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadNil, .loadNil): return {
        guard case .loadNil(let l) = lhs, case .loadNil(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadPair, .loadPair): return {
        guard case .loadPair(let l) = lhs, case .loadPair(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginTable, .beginTable): return {
        guard case .beginTable(let l) = lhs, case .beginTable(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tableAddProperty, .tableAddProperty): return {
        guard case .tableAddProperty(let l) = lhs, case .tableAddProperty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tableAddElement, .tableAddElement): return {
        guard case .tableAddElement(let l) = lhs, case .tableAddElement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginTableMethod, .beginTableMethod): return {
        guard case .beginTableMethod(let l) = lhs, case .beginTableMethod(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endTableMethod, .endTableMethod): return {
        guard case .endTableMethod(let l) = lhs, case .endTableMethod(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endTable, .endTable): return {
        guard case .endTable(let l) = lhs, case .endTable(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.createArray, .createArray): return {
        guard case .createArray(let l) = lhs, case .createArray(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadBuiltin, .loadBuiltin): return {
        guard case .loadBuiltin(let l) = lhs, case .loadBuiltin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getProperty, .getProperty): return {
        guard case .getProperty(let l) = lhs, case .getProperty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setProperty, .setProperty): return {
        guard case .setProperty(let l) = lhs, case .setProperty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.updateProperty, .updateProperty): return {
        guard case .updateProperty(let l) = lhs, case .updateProperty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleteProperty, .deleteProperty): return {
        guard case .deleteProperty(let l) = lhs, case .deleteProperty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getElement, .getElement): return {
        guard case .getElement(let l) = lhs, case .getElement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setElement, .setElement): return {
        guard case .setElement(let l) = lhs, case .setElement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.updateElement, .updateElement): return {
        guard case .updateElement(let l) = lhs, case .updateElement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleteElement, .deleteElement): return {
        guard case .deleteElement(let l) = lhs, case .deleteElement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginFunction, .beginFunction): return {
        guard case .beginFunction(let l) = lhs, case .beginFunction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endFunction, .endFunction): return {
        guard case .endFunction(let l) = lhs, case .endFunction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.return, .return): return {
        guard case .return(let l) = lhs, case .return(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.callFunction, .callFunction): return {
        guard case .callFunction(let l) = lhs, case .callFunction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.callMethod, .callMethod): return {
        guard case .callMethod(let l) = lhs, case .callMethod(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unaryOperation, .unaryOperation): return {
        guard case .unaryOperation(let l) = lhs, case .unaryOperation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.binaryOperation, .binaryOperation): return {
        guard case .binaryOperation(let l) = lhs, case .binaryOperation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.update, .update): return {
        guard case .update(let l) = lhs, case .update(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reassign, .reassign): return {
        guard case .reassign(let l) = lhs, case .reassign(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.compare, .compare): return {
        guard case .compare(let l) = lhs, case .compare(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginIf, .beginIf): return {
        guard case .beginIf(let l) = lhs, case .beginIf(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginElse, .beginElse): return {
        guard case .beginElse(let l) = lhs, case .beginElse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endIf, .endIf): return {
        guard case .endIf(let l) = lhs, case .endIf(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginWhileLoopHeader, .beginWhileLoopHeader): return {
        guard case .beginWhileLoopHeader(let l) = lhs, case .beginWhileLoopHeader(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginWhileLoopBody, .beginWhileLoopBody): return {
        guard case .beginWhileLoopBody(let l) = lhs, case .beginWhileLoopBody(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endWhileLoop, .endWhileLoop): return {
        guard case .endWhileLoop(let l) = lhs, case .endWhileLoop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginForLoopInitializer, .beginForLoopInitializer): return {
        guard case .beginForLoopInitializer(let l) = lhs, case .beginForLoopInitializer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginForLoopCondition, .beginForLoopCondition): return {
        guard case .beginForLoopCondition(let l) = lhs, case .beginForLoopCondition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginForLoopAfterthought, .beginForLoopAfterthought): return {
        guard case .beginForLoopAfterthought(let l) = lhs, case .beginForLoopAfterthought(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginForLoopBody, .beginForLoopBody): return {
        guard case .beginForLoopBody(let l) = lhs, case .beginForLoopBody(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endForLoop, .endForLoop): return {
        guard case .endForLoop(let l) = lhs, case .endForLoop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginForInLoop, .beginForInLoop): return {
        guard case .beginForInLoop(let l) = lhs, case .beginForInLoop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endForInLoop, .endForInLoop): return {
        guard case .endForInLoop(let l) = lhs, case .endForInLoop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginRepeatLoop, .beginRepeatLoop): return {
        guard case .beginRepeatLoop(let l) = lhs, case .beginRepeatLoop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endRepeatLoop, .endRepeatLoop): return {
        guard case .endRepeatLoop(let l) = lhs, case .endRepeatLoop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loopBreak, .loopBreak): return {
        guard case .loopBreak(let l) = lhs, case .loopBreak(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.label, .label): return {
        guard case .label(let l) = lhs, case .label(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.goto, .goto): return {
        guard case .goto(let l) = lhs, case .goto(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.nop, .nop): return {
        guard case .nop(let l) = lhs, case .nop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct FuzzilliLua_Protobuf_Program {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uuid: Data {
    get {return _storage._uuid}
    set {_uniqueStorage()._uuid = newValue}
  }

  public var code: [FuzzilliLua_Protobuf_Instruction] {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var comments: Dictionary<Int32,String> {
    get {return _storage._comments}
    set {_uniqueStorage()._comments = newValue}
  }

  public var parent: FuzzilliLua_Protobuf_Program {
    get {return _storage._parent ?? FuzzilliLua_Protobuf_Program()}
    set {_uniqueStorage()._parent = newValue}
  }
  /// Returns true if `parent` has been explicitly set.
  public var hasParent: Bool {return _storage._parent != nil}
  /// Clears the value of `parent`. Subsequent reads from it will return its default value.
  public mutating func clearParent() {_uniqueStorage()._parent = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "fuzzilli_lua.protobuf"

extension FuzzilliLua_Protobuf_Instruction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Instruction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inouts"),
    52: .same(proto: "numinputs"),
    53: .same(proto: "numoutputs"),
    54: .same(proto: "numinneroutputs"),
    2: .same(proto: "opIdx"),
    3: .same(proto: "loadNumber"),
    4: .same(proto: "loadString"),
    5: .same(proto: "loadBoolean"),
    6: .same(proto: "loadNil"),
    7: .same(proto: "loadPair"),
    8: .same(proto: "beginTable"),
    9: .same(proto: "tableAddProperty"),
    10: .same(proto: "tableAddElement"),
    11: .same(proto: "beginTableMethod"),
    12: .same(proto: "endTableMethod"),
    13: .same(proto: "endTable"),
    14: .same(proto: "createArray"),
    15: .same(proto: "loadBuiltin"),
    16: .same(proto: "getProperty"),
    17: .same(proto: "setProperty"),
    18: .same(proto: "updateProperty"),
    19: .same(proto: "deleteProperty"),
    20: .same(proto: "GetElement"),
    21: .same(proto: "setElement"),
    22: .same(proto: "updateElement"),
    23: .same(proto: "deleteElement"),
    24: .same(proto: "beginFunction"),
    25: .same(proto: "endFunction"),
    26: .same(proto: "return"),
    27: .same(proto: "callFunction"),
    28: .same(proto: "callMethod"),
    29: .same(proto: "unaryOperation"),
    30: .same(proto: "binaryOperation"),
    31: .same(proto: "update"),
    32: .same(proto: "reassign"),
    33: .same(proto: "compare"),
    34: .same(proto: "beginIf"),
    35: .same(proto: "beginElse"),
    36: .same(proto: "endIf"),
    37: .same(proto: "beginWhileLoopHeader"),
    38: .same(proto: "beginWhileLoopBody"),
    39: .same(proto: "endWhileLoop"),
    40: .same(proto: "beginForLoopInitializer"),
    41: .same(proto: "beginForLoopCondition"),
    42: .same(proto: "beginForLoopAfterthought"),
    43: .same(proto: "beginForLoopBody"),
    44: .same(proto: "endForLoop"),
    45: .same(proto: "beginForInLoop"),
    46: .same(proto: "endForInLoop"),
    47: .same(proto: "beginRepeatLoop"),
    48: .same(proto: "endRepeatLoop"),
    49: .same(proto: "loopBreak"),
    50: .same(proto: "label"),
    51: .same(proto: "goto"),
    64: .same(proto: "nop"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt32Field(value: &self.inouts) }()
      case 2: try {
        if self.operation != nil {try decoder.handleConflictingOneOf()}
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {self.operation = .opIdx(v)}
      }()
      case 3: try {
        var v: FuzzilliLua_Protobuf_LoadNumber?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .loadNumber(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .loadNumber(v)}
      }()
      case 4: try {
        var v: FuzzilliLua_Protobuf_LoadString?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .loadString(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .loadString(v)}
      }()
      case 5: try {
        var v: FuzzilliLua_Protobuf_LoadBoolean?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .loadBoolean(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .loadBoolean(v)}
      }()
      case 6: try {
        var v: FuzzilliLua_Protobuf_LoadNil?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .loadNil(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .loadNil(v)}
      }()
      case 7: try {
        var v: FuzzilliLua_Protobuf_LoadPair?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .loadPair(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .loadPair(v)}
      }()
      case 8: try {
        var v: FuzzilliLua_Protobuf_BeginTable?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .beginTable(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .beginTable(v)}
      }()
      case 9: try {
        var v: FuzzilliLua_Protobuf_TableAddProperty?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .tableAddProperty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .tableAddProperty(v)}
      }()
      case 10: try {
        var v: FuzzilliLua_Protobuf_TableAddElement?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .tableAddElement(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .tableAddElement(v)}
      }()
      case 11: try {
        var v: FuzzilliLua_Protobuf_BeginTableMethod?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .beginTableMethod(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .beginTableMethod(v)}
      }()
      case 12: try {
        var v: FuzzilliLua_Protobuf_EndTableMethod?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .endTableMethod(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .endTableMethod(v)}
      }()
      case 13: try {
        var v: FuzzilliLua_Protobuf_EndTable?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .endTable(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .endTable(v)}
      }()
      case 14: try {
        var v: FuzzilliLua_Protobuf_CreateArray?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .createArray(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .createArray(v)}
      }()
      case 15: try {
        var v: FuzzilliLua_Protobuf_LoadBuiltin?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .loadBuiltin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .loadBuiltin(v)}
      }()
      case 16: try {
        var v: FuzzilliLua_Protobuf_GetProperty?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .getProperty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .getProperty(v)}
      }()
      case 17: try {
        var v: FuzzilliLua_Protobuf_SetProperty?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .setProperty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .setProperty(v)}
      }()
      case 18: try {
        var v: FuzzilliLua_Protobuf_UpdateProperty?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .updateProperty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .updateProperty(v)}
      }()
      case 19: try {
        var v: FuzzilliLua_Protobuf_DeleteProperty?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .deleteProperty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .deleteProperty(v)}
      }()
      case 20: try {
        var v: FuzzilliLua_Protobuf_GetElement?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .getElement(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .getElement(v)}
      }()
      case 21: try {
        var v: FuzzilliLua_Protobuf_SetElement?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .setElement(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .setElement(v)}
      }()
      case 22: try {
        var v: FuzzilliLua_Protobuf_UpdateElement?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .updateElement(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .updateElement(v)}
      }()
      case 23: try {
        var v: FuzzilliLua_Protobuf_DeleteElement?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .deleteElement(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .deleteElement(v)}
      }()
      case 24: try {
        var v: FuzzilliLua_Protobuf_BeginFunction?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .beginFunction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .beginFunction(v)}
      }()
      case 25: try {
        var v: FuzzilliLua_Protobuf_EndFunction?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .endFunction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .endFunction(v)}
      }()
      case 26: try {
        var v: FuzzilliLua_Protobuf_Return?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .return(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .return(v)}
      }()
      case 27: try {
        var v: FuzzilliLua_Protobuf_CallFunction?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .callFunction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .callFunction(v)}
      }()
      case 28: try {
        var v: FuzzilliLua_Protobuf_CallMethod?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .callMethod(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .callMethod(v)}
      }()
      case 29: try {
        var v: FuzzilliLua_Protobuf_UnaryOperation?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .unaryOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .unaryOperation(v)}
      }()
      case 30: try {
        var v: FuzzilliLua_Protobuf_BinaryOperation?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .binaryOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .binaryOperation(v)}
      }()
      case 31: try {
        var v: FuzzilliLua_Protobuf_Update?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .update(v)}
      }()
      case 32: try {
        var v: FuzzilliLua_Protobuf_Reassign?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .reassign(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .reassign(v)}
      }()
      case 33: try {
        var v: FuzzilliLua_Protobuf_Compare?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .compare(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .compare(v)}
      }()
      case 34: try {
        var v: FuzzilliLua_Protobuf_BeginIf?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .beginIf(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .beginIf(v)}
      }()
      case 35: try {
        var v: FuzzilliLua_Protobuf_BeginElse?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .beginElse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .beginElse(v)}
      }()
      case 36: try {
        var v: FuzzilliLua_Protobuf_EndIf?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .endIf(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .endIf(v)}
      }()
      case 37: try {
        var v: FuzzilliLua_Protobuf_BeginWhileLoopHeader?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .beginWhileLoopHeader(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .beginWhileLoopHeader(v)}
      }()
      case 38: try {
        var v: FuzzilliLua_Protobuf_BeginWhileLoopBody?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .beginWhileLoopBody(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .beginWhileLoopBody(v)}
      }()
      case 39: try {
        var v: FuzzilliLua_Protobuf_EndWhileLoop?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .endWhileLoop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .endWhileLoop(v)}
      }()
      case 40: try {
        var v: FuzzilliLua_Protobuf_BeginForLoopInitializer?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .beginForLoopInitializer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .beginForLoopInitializer(v)}
      }()
      case 41: try {
        var v: FuzzilliLua_Protobuf_BeginForLoopCondition?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .beginForLoopCondition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .beginForLoopCondition(v)}
      }()
      case 42: try {
        var v: FuzzilliLua_Protobuf_BeginForLoopAfterthought?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .beginForLoopAfterthought(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .beginForLoopAfterthought(v)}
      }()
      case 43: try {
        var v: FuzzilliLua_Protobuf_BeginForLoopBody?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .beginForLoopBody(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .beginForLoopBody(v)}
      }()
      case 44: try {
        var v: FuzzilliLua_Protobuf_EndForLoop?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .endForLoop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .endForLoop(v)}
      }()
      case 45: try {
        var v: FuzzilliLua_Protobuf_BeginForInLoop?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .beginForInLoop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .beginForInLoop(v)}
      }()
      case 46: try {
        var v: FuzzilliLua_Protobuf_EndForInLoop?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .endForInLoop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .endForInLoop(v)}
      }()
      case 47: try {
        var v: FuzzilliLua_Protobuf_BeginRepeatLoop?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .beginRepeatLoop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .beginRepeatLoop(v)}
      }()
      case 48: try {
        var v: FuzzilliLua_Protobuf_EndRepeatLoop?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .endRepeatLoop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .endRepeatLoop(v)}
      }()
      case 49: try {
        var v: FuzzilliLua_Protobuf_LoopBreak?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .loopBreak(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .loopBreak(v)}
      }()
      case 50: try {
        var v: FuzzilliLua_Protobuf_Label?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .label(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .label(v)}
      }()
      case 51: try {
        var v: FuzzilliLua_Protobuf_Goto?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .goto(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .goto(v)}
      }()
      case 52: try { try decoder.decodeSingularUInt32Field(value: &self.numinputs) }()
      case 53: try { try decoder.decodeSingularUInt32Field(value: &self.numoutputs) }()
      case 54: try { try decoder.decodeSingularUInt32Field(value: &self.numinneroutputs) }()
      case 64: try {
        var v: FuzzilliLua_Protobuf_Nop?
        if let current = self.operation {
          try decoder.handleConflictingOneOf()
          if case .nop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.operation = .nop(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inouts.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.inouts, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.operation {
    case .opIdx?: try {
      guard case .opIdx(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }()
    case .loadNumber?: try {
      guard case .loadNumber(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .loadString?: try {
      guard case .loadString(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .loadBoolean?: try {
      guard case .loadBoolean(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .loadNil?: try {
      guard case .loadNil(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .loadPair?: try {
      guard case .loadPair(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .beginTable?: try {
      guard case .beginTable(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .tableAddProperty?: try {
      guard case .tableAddProperty(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .tableAddElement?: try {
      guard case .tableAddElement(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .beginTableMethod?: try {
      guard case .beginTableMethod(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .endTableMethod?: try {
      guard case .endTableMethod(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .endTable?: try {
      guard case .endTable(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .createArray?: try {
      guard case .createArray(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .loadBuiltin?: try {
      guard case .loadBuiltin(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .getProperty?: try {
      guard case .getProperty(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .setProperty?: try {
      guard case .setProperty(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .updateProperty?: try {
      guard case .updateProperty(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .deleteProperty?: try {
      guard case .deleteProperty(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .getElement?: try {
      guard case .getElement(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .setElement?: try {
      guard case .setElement(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .updateElement?: try {
      guard case .updateElement(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .deleteElement?: try {
      guard case .deleteElement(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .beginFunction?: try {
      guard case .beginFunction(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .endFunction?: try {
      guard case .endFunction(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .return?: try {
      guard case .return(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case .callFunction?: try {
      guard case .callFunction(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .callMethod?: try {
      guard case .callMethod(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .unaryOperation?: try {
      guard case .unaryOperation(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    case .binaryOperation?: try {
      guard case .binaryOperation(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .update?: try {
      guard case .update(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .reassign?: try {
      guard case .reassign(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .compare?: try {
      guard case .compare(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
    }()
    case .beginIf?: try {
      guard case .beginIf(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
    }()
    case .beginElse?: try {
      guard case .beginElse(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
    }()
    case .endIf?: try {
      guard case .endIf(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
    }()
    case .beginWhileLoopHeader?: try {
      guard case .beginWhileLoopHeader(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
    }()
    case .beginWhileLoopBody?: try {
      guard case .beginWhileLoopBody(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
    }()
    case .endWhileLoop?: try {
      guard case .endWhileLoop(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
    }()
    case .beginForLoopInitializer?: try {
      guard case .beginForLoopInitializer(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
    }()
    case .beginForLoopCondition?: try {
      guard case .beginForLoopCondition(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
    }()
    case .beginForLoopAfterthought?: try {
      guard case .beginForLoopAfterthought(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
    }()
    case .beginForLoopBody?: try {
      guard case .beginForLoopBody(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
    }()
    case .endForLoop?: try {
      guard case .endForLoop(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
    }()
    case .beginForInLoop?: try {
      guard case .beginForInLoop(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
    }()
    case .endForInLoop?: try {
      guard case .endForInLoop(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
    }()
    case .beginRepeatLoop?: try {
      guard case .beginRepeatLoop(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
    }()
    case .endRepeatLoop?: try {
      guard case .endRepeatLoop(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
    }()
    case .loopBreak?: try {
      guard case .loopBreak(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
    }()
    case .label?: try {
      guard case .label(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
    }()
    case .goto?: try {
      guard case .goto(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
    }()
    default: break
    }
    if self.numinputs != 0 {
      try visitor.visitSingularUInt32Field(value: self.numinputs, fieldNumber: 52)
    }
    if self.numoutputs != 0 {
      try visitor.visitSingularUInt32Field(value: self.numoutputs, fieldNumber: 53)
    }
    if self.numinneroutputs != 0 {
      try visitor.visitSingularUInt32Field(value: self.numinneroutputs, fieldNumber: 54)
    }
    if case .nop(let v)? = self.operation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 64)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FuzzilliLua_Protobuf_Instruction, rhs: FuzzilliLua_Protobuf_Instruction) -> Bool {
    if lhs.inouts != rhs.inouts {return false}
    if lhs.numinputs != rhs.numinputs {return false}
    if lhs.numoutputs != rhs.numoutputs {return false}
    if lhs.numinneroutputs != rhs.numinneroutputs {return false}
    if lhs.operation != rhs.operation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FuzzilliLua_Protobuf_Program: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Program"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "code"),
    3: .same(proto: "comments"),
    4: .same(proto: "parent"),
  ]

  fileprivate class _StorageClass {
    var _uuid: Data = Data()
    var _code: [FuzzilliLua_Protobuf_Instruction] = []
    var _comments: Dictionary<Int32,String> = [:]
    var _parent: FuzzilliLua_Protobuf_Program? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _uuid = source._uuid
      _code = source._code
      _comments = source._comments
      _parent = source._parent
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._uuid) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._code) }()
        case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufSInt32,SwiftProtobuf.ProtobufString>.self, value: &_storage._comments) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._parent) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._uuid.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._uuid, fieldNumber: 1)
      }
      if !_storage._code.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._code, fieldNumber: 2)
      }
      if !_storage._comments.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufSInt32,SwiftProtobuf.ProtobufString>.self, value: _storage._comments, fieldNumber: 3)
      }
      if let v = _storage._parent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FuzzilliLua_Protobuf_Program, rhs: FuzzilliLua_Protobuf_Program) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._code != rhs_storage._code {return false}
        if _storage._comments != rhs_storage._comments {return false}
        if _storage._parent != rhs_storage._parent {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
